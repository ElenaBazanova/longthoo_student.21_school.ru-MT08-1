# Docker и Kubernetes

## 1. Что такое Docker? Для чего он используется?  

**Docker** — это программная платформа для разработки, доставки и запуска контейнерных приложений. Он позволяет создавать контейнеры, автоматизировать их запуск и развертывание, управляет жизненным циклом.  
С помощью Docker можно запускать множество контейнеров на одной хост-машине.

**Контейнеризация** — это способ упаковки приложения и всех его зависимостей в один образ, который запускается в изолированной среде, не влияющей на основную операционную систему. С помощью контейнера можно отделить приложение от инфраструктуры: не важно, в каком окружении оно будет работать, есть ли там нужные зависимости и настройки, — разработчикам достаточно создать программу и упаковать все зависимости и настройки в единый образ. Затем ее можно разворачивать и запускать на других системах. Это ускоряет процесс разработки, сокращает промежуток между написанием кода и его выкладкой.

**Docker** — клиент-серверное приложение. Это означает, что оно состоит из двух частей: сервера и клиента.

Сервер еще называют **Docker-движком или демоном (daemon)**. Это фоновый процесс, который непосредственно управляет контейнерами. Именно демон создает, разворачивает и запускает контейнеры. Его можно сравнить с двигателем машины.

**Клиент** — это программа-интерфейс для командной строки, с которой взаимодействует пользователь. Он отдает команды через терминал. Клиент сообщает нужные сведения демону и отдает ему указания.  

Клиент и сервер могут находиться на одном устройстве, а могут — на разных. Во втором случае клиент подключают к удаленному серверу через сокеты или API. 

Docker работает со следующими компонентами.

- Dockerfile. Это файл для предварительной работы, набор инструкций, который нужен для записи образа. В нем описывается, что должно находиться в образе, какие команды, зависимости и процессы он будет содержать.

Для сборки образа из Dockerfile используют команду:

*docker build <докерфайл>*

- Docker Image. Это образ — неизменяемый файл, из которого разворачивается контейнер. Для этого нужно запустить образ в клиенте с помощью специальной команды:

*docker run <образ>*

- Docker Registry. Это реестр, или репозиторий — открытая или закрытая база образов. К ней можно подключиться через клиент Docker и загрузить нужный с помощью команды:

*docker pull <образ>*

При запуске команды docker run программа сначала проверяет, есть ли нужный образ в локальном хранилище. Если его нет, она сама находит файл в репозитории и скачивает на компьютер.

- Docker Container. Это уже готовый и развернутый контейнер, который находится на каком-либо устройстве.

Так пользователь запускает нужный образ через клиент Docker и ждет, пока платформа развернет его в полноценную среду или приложение-контейнер.

Образ можно создать самостоятельно с помощью Dockerfile или уже готового контейнера, в котором произошли какие-либо изменения, а также скачать из открытого репозитория Docker Hub.

Разработчики со всего мира могут выкладывать Docker-образы. Другие пользователи имеют возможность скачать их, развернуть в контейнеры и использовать на своих машинах. 

Сейчас в Docker Hub более 100 тысяч образов. Некоторые из них загрузили в базу официальные разработчики. Это, например, Docker Images для mySQL или GitLab.

Поддержка репозитория уже включена в Docker. Это значит, что достаточно написать команду для установки какой-либо программы, и система сама начнет искать ее в базе данных. По умолчанию это Docker Hub, но платформу можно настроить и под другие репозитории. Например, под внутренние корпоративные базы.

## 2. Чем Docker отличается от виртуальной машины?

**Виртуальная машина** - это система, которая действует точно так же, как компьютер. Виртуальные машины позволяют запускать операционную систему в приложении, которое ведет себя как полноценный отдельный компьютер. Вы можете использовать их для работы с различными операционными системами, запускать программное обеспечение, которое не может работать на вашей основной ОС.

Основные отличия Docker от виртуальной машины:

| Виртуальная машина                                   	| Docker контейнер                                          	|
|------------------------------------------------------	|-----------------------------------------------------------	|
| Изоляция процесса на аппаратном уровне               	| Изоляция процесса на уровне ОС                            	|
| Каждая виртуальная машина имеет отдельную ОС         	| Каждый контейнер может совместно использовать ОС          	|
| Загружается в считанные минуты                       	| Загружается в считанные секунды                           	|
| Виртуальные машины занимают несколько ГБ             	| Контейнеры легкие (КБ / МБ)                               	|
| Готовые виртуальные машины трудно найти              	| Готовые док-контейнеры легко доступны                     	|
| Виртуальные машины могут легко перейти на новый хост 	| Контейнеры уничтожаются и воссоздаются, а не перемещаются 	|
| Создание ВМ занимает относительно больше времени     	| Контейнеры могут быть созданы в считанные секунды         	|
| Больше использования ресурса                         	| Меньшее использование ресурсов                            	|

## 3. Что такое Docker Compose

Считается, что один контейнер должен выполнять одну функцию. Поэтому для настройки сложной среды понадобится несколько образов.

Можно скачать их вручную и настроить либо воспользоваться Docker Compose — инструментом для работы с множественными образами и многоконтейнерными приложениями.

ПО позволяет управлять несколькими образами и контейнерами как одним. С помощью Docker Compose можно создать файл YAML для определения служб и с одной командой запускать и останавливать все что нужно. Инструмент способен ускорить разработку: в многоконтейнерных приложениях количество контейнеров может доходить до нескольких десятков.

## 4. Что такое Kubernetes? Для чего используется?

Kubernetes является проектом с открытым исходным кодом, предназначенным для управления кластером контейнеров Linux как единой системой. Kubernetes управляет и запускает контейнеры Docker на большом количестве хостов, а так же обеспечивает совместное размещение и репликацию большого количества контейнеров. Проект был начат Google и теперь поддерживается многими компаниями, среди которых Microsoft, RedHat, IBM и Docker.

Компания Google пользуется контейнерной технологией уже более десяти лет. Она начинала с запуска более 2 млрд контейнеров в течение одной недели. С помощью проекта Kubernetes компания делится своим опытом создания открытой платформы, предназначенной для масштабируемого запуска контейнеров.

Проект преследует две цели. Если вы пользуетесь контейнерами Docker, возникает следующий вопрос о том, как масштабировать и запускать контейнеры сразу на большом количестве хостов Docker, а также как выполнять их балансировку. В проекте предлагается высокоуровневый API, определяющее логическое группирование контейнеров, позволяющее определять пулы контейнеров, балансировать нагрузку, а также задавать их размещение.

**Концепции Kubernetes**

Nodes (node.md): Нода это машина в кластере Kubernetes.
Pods (pods.md): Pod это группа контейнеров с общими разделами, запускаемых как единое целое.
Replication Controllers (replication-controller.md): replication controller гарантирует, что определенное количество «реплик» pod'ы будут запущены в любой момент времени.
Services (services.md): Сервис в Kubernetes это абстракция которая определяет логический объединённый набор pod и политику доступа к ним.
Volumes (volumes.md): Volume(раздел) это директория, возможно, с данными в ней, которая доступна в контейнере.
Labels (labels.md): Label'ы это пары ключ/значение которые прикрепляются к объектам, например pod'ам. Label'ы могут быть использованы для создания и выбора наборов объектов.
Kubectl Command Line Interface (kubectl.md): kubectl интерфейс командной строки для управления Kubernetes.

**Архитектура Kubernetes**

Работающий кластер Kubernetes включает в себя агента, запущенного на нодах (kubelet) и компоненты мастера (APIs, scheduler, etc), поверх решения с распределённым хранилищем. Приведённая схема показывает желаемое, в конечном итоге, состояние, хотя все ещё ведётся работа над некоторыми вещами, например: как сделать так, чтобы kubelet (все компоненты, на самом деле) самостоятельно запускался в контейнере, что сделает планировщик на 100% подключаемым.

**Нода Kubernetes**

При взгляде на архитектуру системы мы можем разбить его на сервисы, которые работают на каждой ноде и сервисы уровня управления кластера. На каждой ноде Kubernetes запускаются сервисы, необходимые для управления нодой со стороны мастера и для запуска приложений. Конечно, на каждой ноде запускается Docker. Docker обеспечивает загрузку образов и запуск контейнеров.

**Kubelet**

Kubelet управляет pod'ами их контейнерами, образами, разделами, etc.

**Kube-Proxy**

Также на каждой ноде запускается простой proxy-балансировщик. Этот сервис запускается на каждой ноде и настраивается в Kubernetes API. Kube-Proxy может выполнять простейшее перенаправление потоков TCP и UDP (round robin) между набором бэкендов.

**Компоненты управления Kubernetes**

Система управления Kubernetes разделена на несколько компонентов. В данный момент все они запускаются на мастер-ноде, но в скором времени это будет изменено для возможности создания отказоустойчивого кластера. Эти компоненты работают вместе, чтобы обеспечить единое представление кластера.

**etcd**

Состояние мастера хранится в экземпляре etcd. Это обеспечивает надёжное хранение конфигурационных данных и своевременное оповещение прочих компонентов об изменении состояния.

**Kubernetes API Server**

Kubernetes API обеспечивает работу api-сервера. Он предназначен для того, чтобы быть CRUD сервером со встроенной бизнес-логикой, реализованной в отдельных компонентах или в плагинах. Он, в основном, обрабатывает REST операции, проверяя их и обновляя соответствующие объекты в etcd (и событийно в других хранилищах).

**Scheduler**

Scheduler привязывает незапущенные pod'ы к нодам через вызов /binding API. Scheduler подключаем; планируется поддержка множественных scheduler'ов и пользовательских scheduler'ов.

**Kubernetes Controller Manager Server**

Все остальные функции уровня кластера представлены в Controller Manager. Например, ноды обнаруживаются, управляются и контролируются средствами node controller. Эта сущность в итоге может быть разделена на отдельные компоненты, чтобы сделать их независимо подключаемыми.

ReplicationController — это механизм, основывающийся на pod API. В конечном счете планируется перевести её на общий механизм plug-in, когда он будет реализован.



